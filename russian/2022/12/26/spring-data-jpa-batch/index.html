<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Батчевое сохранение в Spring Data JPA - Jaitl's blog</title><meta name=description content="В этой статье я исследую стратегии генерации идентификаторов для записей на предмет их совместимости с батчевой вставкой в БД. В качестве ORM используется Spring Data JPA, а в качестве БД - PostgreSQL."><meta name=author content="Jaitl"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Jaitl\u0027s blog","url":"https:\/\/jaitl.pro"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/jaitl.pro"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/jaitl.pro","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/jaitl.pro\/russian\/2022\/12\/26\/spring-data-jpa-batch\/","name":"Батчевое сохранение в spring data jpa"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Jaitl"},"headline":"Батчевое сохранение в Spring Data JPA","description":"В этой статье я исследую стратегии генерации идентификаторов для записей на предмет их совместимости с батчевой вставкой в БД. В качестве ORM используется Spring Data JPA, а в качестве БД - PostgreSQL.\n","inLanguage":"en","wordCount":1589,"datePublished":"2022-12-26T12:00:00","dateModified":"2022-12-26T12:00:00","image":"https:\/\/jaitl.pro\/img\/jaitl-avatar.png","keywords":[""],"mainEntityOfPage":"https:\/\/jaitl.pro\/russian\/2022\/12\/26\/spring-data-jpa-batch\/","publisher":{"@type":"Organization","name":"https:\/\/jaitl.pro","logo":{"@type":"ImageObject","url":"https:\/\/jaitl.pro\/img\/jaitl-avatar.png","height":60,"width":60}}}</script><meta property="og:title" content="Батчевое сохранение в Spring Data JPA"><meta property="og:description" content="В этой статье я исследую стратегии генерации идентификаторов для записей на предмет их совместимости с батчевой вставкой в БД. В качестве ORM используется Spring Data JPA, а в качестве БД - PostgreSQL."><meta property="og:image" content="https://jaitl.pro/img/jaitl-avatar.png"><meta property="og:url" content="https://jaitl.pro/russian/2022/12/26/spring-data-jpa-batch/"><meta property="og:type" content="website"><meta property="og:site_name" content="Jaitl's blog"><meta name=twitter:title content="Батчевое сохранение в Spring Data JPA"><meta name=twitter:description content="В этой статье я исследую стратегии генерации идентификаторов для записей на предмет их совместимости с батчевой вставкой в БД. В качестве ORM используется Spring Data JPA, а в качестве БД - …"><meta name=twitter:image content="https://jaitl.pro/img/jaitl-avatar.png"><meta name=twitter:card content="summary"><meta name=twitter:site content="@jaitl"><meta name=twitter:creator content="@jaitl"><link href=https://jaitl.pro/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.83.1"><link rel=alternate href=https://jaitl.pro/index.xml type=application/rss+xml title="Jaitl's blog"><link rel=stylesheet href=https://jaitl.pro/css/katex.min.css><link rel=stylesheet href=https://jaitl.pro/fontawesome/css/all.css><link rel=stylesheet href=https://jaitl.pro/css/bootstrap.min.css><link rel=stylesheet href=https://jaitl.pro/css/main.css><link rel=stylesheet href=https://jaitl.pro/css/fonts.css><link rel=stylesheet href=https://jaitl.pro/css/syntax.css><link rel=stylesheet href=https://jaitl.pro/css/codeblock.css><link rel=stylesheet href=https://jaitl.pro/css/photoswipe.min.css><link rel=stylesheet href=https://jaitl.pro/css/photoswipe.default-skin.min.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-KBJ7QRKR1F"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-KBJ7QRKR1F',{anonymize_ip:!1})}</script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=https://jaitl.pro>Jaitl's blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title="Russian Blog" href=/russian>Russian Blog</a></li><li><a title="Telegram Channel" href=https://t.me/seniorsITBlog>Telegram Channel</a></li><li><a title="About Me" href=/about>About Me</a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Jaitl's blog" href=https://jaitl.pro><img class=avatar-img src=https://jaitl.pro/img/jaitl-avatar.png alt="Jaitl's blog"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=russian-heading><h1>Батчевое сохранение в Spring Data JPA</h1><hr class=small></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>В этой статье я исследую стратегии генерации идентификаторов для записей на предмет их совместимости с батчевой вставкой в БД. В качестве ORM используется Spring Data JPA, а в качестве БД - PostgreSQL.</p><p>У меня появилась задача выполнять сохранение данных в батчевом режиеме. В качестве базы данных в проекте у меня используется PostgreSQL.</p><p>Я провел теоретическое исследование, в результате которого выяснилось, что для батчевой вставки (batch insert) данных идентификаторы должны генерироваться с использованием стратегии <code>GenerationType.SEQUENCE</code>, которая в свою очередь использует отдельную сущность в БД под названием <code>sequence</code> для батчевой генерации идентификаторов (primary key).</p><p>Теоретическое исследование статей в интернете показывает, что стратегия <code>GenerationType.IDENTITY</code> позволяющая использовать стандартный тип <code>serial</code> для авто-генерации идентификаторов не работает с батчевой вставкой. Судя по документации в случае <code>GenerationType.IDENTITY</code> спринг игнорирует батчевую вставку даже если она включена в настройках.</p><blockquote><p>When we want to use batching for inserts, we should be aware of the primary key generation strategy. If our entities use the GenerationType.IDENTITY identifier generator, Hibernate will silently disable batch inserts.</p></blockquote><p><a href=https://www.baeldung.com/jpa-hibernate-batch-insert-update#id-generation-strategy>baeldung.com</a></p><p>Я не люблю плодить дополнительные сущности, я бы хотел и дальше использовать тип <code>serial</code> для идентификаторов не создавая дополнительно сущность <code>sequence</code>, поэтому в этой статье я хочу провести практическое исследование и выяснить возможно ли использовать стратегию <code>GenerationType.IDENTITY</code> для генерирования идентификаторов при батчевой вставке.</p><h2 id=включение-батчевой-вставки-и-логирования-запросов>Включение батчевой вставки и логирования запросов</h2><div class=highlight><pre class=chroma><code class=language-yaml data-lang=yaml><span class=nt>spring</span><span class=p>:</span><span class=w>
</span><span class=w>  </span><span class=nt>jpa</span><span class=p>:</span><span class=w>  
</span><span class=w>    </span><span class=nt>show-sql</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>  
</span><span class=w>      </span><span class=nt>properties</span><span class=p>:</span><span class=w>  
</span><span class=w>        </span><span class=nt>hibernate</span><span class=p>:</span><span class=w>  
</span><span class=w>          </span><span class=nt>generate_statistics</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span><span class=w>          </span><span class=nt>order_inserts</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span><span class=w>          </span><span class=nt>jdbc.batch_size</span><span class=p>:</span><span class=w> </span><span class=m>100</span><span class=w>
</span></code></pre></div><p>Флаги:</p><ul><li><code>show-sql</code> - включает логирование запросов</li><li><code>generate_statistics</code> - включает генерирование статистики о запросах</li><li><code>order_inserts</code> - включает сортировку запросов по имени таблицы. В случае если инсерты не отсортированы по имени таблицы, они не могут быть объеденины в один батч и будут разделены на несколько батчей</li><li><code>batch_size</code> - максимальный размер батча</li></ul><h2 id=generationtypeidentity>GenerationType.IDENTITY</h2><p>Начнем эксперимент со стратегии <code>GenerationType.IDENTITY</code>. Ниже приветен код sql создания таблицы для сущности, код сущности, репозитория и теста, полный код можно найти на <a href=https://github.com/jaitl/spring-jpa-batch-insert>Github</a>.</p><h3 id=sql-код-таблицы>SQL код таблицы</h3><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>create</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>identity_table</span><span class=w>  
</span><span class=w></span><span class=p>(</span><span class=w>  
</span><span class=w>    </span><span class=n>id</span><span class=w>    </span><span class=nb>serial</span><span class=w> </span><span class=k>primary</span><span class=w> </span><span class=k>key</span><span class=p>,</span><span class=w>  
</span><span class=w>    </span><span class=n>name</span><span class=w>  </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w>  </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>  
</span><span class=w>    </span><span class=n>ts</span><span class=w>    </span><span class=k>timestamp</span><span class=w>    </span><span class=k>default</span><span class=w> </span><span class=n>now</span><span class=p>()</span><span class=w>  
</span><span class=w></span><span class=p>);</span><span class=w>
</span></code></pre></div><h3 id=identityentity>IdentityEntity</h3><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@Entity</span>
<span class=nd>@Table</span><span class=o>(</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;identity_table&#34;</span><span class=o>)</span>  
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>IdentityEntity</span> <span class=o>{</span>  
  <span class=nd>@Id</span>  
  <span class=nd>@GeneratedValue</span><span class=o>(</span><span class=n>strategy</span> <span class=o>=</span> <span class=n>GenerationType</span><span class=o>.</span><span class=na>IDENTITY</span><span class=o>)</span>  
  <span class=kd>private</span> <span class=n>Integer</span> <span class=n>id</span><span class=o>;</span>  
  
  <span class=kd>private</span> <span class=n>String</span> <span class=n>name</span><span class=o>;</span>  
  
  <span class=kd>private</span> <span class=n>Instant</span> <span class=n>ts</span><span class=o>;</span>  
<span class=o>}</span>
</code></pre></div><h3 id=identityrepository>IdentityRepository</h3><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@Repository</span>  
<span class=kd>public</span> <span class=kd>interface</span> <span class=nc>IdentityRepository</span> <span class=kd>extends</span> <span class=n>JpaRepository</span><span class=o>&lt;</span><span class=n>IdentityEntity</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>  
<span class=o>}</span>
</code></pre></div><h3 id=тест>Тест</h3><p>Размер батча установлен в 100, количество записей которые сохраняются в бд установлена в 1000.</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@SpringBootTest</span>  
<span class=kd>class</span> <span class=nc>IdentityRepositoryBatchTest</span> <span class=o>{</span>  
  
  <span class=nd>@Autowired</span>  
  <span class=kd>private</span> <span class=n>IdentityRepository</span> <span class=n>repository</span><span class=o>;</span>  
  
  <span class=nd>@Test</span>  
  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>()</span> <span class=o>{</span>  
    <span class=kt>long</span> <span class=n>size</span> <span class=o>=</span> <span class=n>1000</span><span class=o>;</span>  
    <span class=n>List</span><span class=o>&lt;</span><span class=n>IdentityEntity</span><span class=o>&gt;</span> <span class=n>identityEntities</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>  
  
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=n>1</span><span class=o>)</span> <span class=o>{</span>  
      <span class=n>IdentityEntity</span> <span class=n>entity</span> <span class=o>=</span> <span class=k>new</span> <span class=n>IdentityEntity</span><span class=o>();</span>  
      <span class=n>entity</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;Test identity number: &#34;</span> <span class=o>+</span> <span class=n>i</span><span class=o>);</span>  
      <span class=n>entity</span><span class=o>.</span><span class=na>setTs</span><span class=o>(</span><span class=n>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>  
      <span class=n>identityEntities</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>entity</span><span class=o>);</span>  
    <span class=o>}</span>  
  
    <span class=n>repository</span><span class=o>.</span><span class=na>saveAll</span><span class=o>(</span><span class=n>identityEntities</span><span class=o>);</span>  
    <span class=n>assertEquals</span><span class=o>(</span><span class=n>size</span><span class=o>,</span> <span class=n>repository</span><span class=o>.</span><span class=na>count</span><span class=o>());</span>  
  <span class=o>}</span>  
<span class=o>}</span>
</code></pre></div><p>Результат:</p><pre><code>114701 nanoseconds spent preparing 1 JDBC statements;
1995614 nanoseconds spent executing 1 JDBC statements;
0 nanoseconds spent executing 0 JDBC batches;
</code></pre><p>Как можно видеть из лога, приложением было выполнено 1000 запросов в БД, а количество батчей - 0. Из чего можно сделать вывод, что батчевые запросы не выполняются даже при включенном в настройках батчевом режиме вставки в случае стратегии <code>GenerationType.IDENTITY</code>.</p><h2 id=generationtypesequence>GenerationType.SEQUENCE</h2><p>Теперь перейдем к стратегии <code>GenerationType.SEQUENCE</code>. Ниже приветен код sql создания таблицы для сущности, код сущности, репозитория и теста, полный код можно найти на <a href=https://github.com/jaitl/spring-jpa-batch-insert>Github</a>.</p><h3 id=sql-код-таблицы-1>SQL код таблицы</h3><p>Как можно заметить тип поля идентификатора - <code>integer</code>, потому что для инкрементальной генерации идентификаторов hibernate будет использовать последовательность <code>sequence_id_auto_gen</code>.</p><div class=highlight><pre class=chroma><code class=language-sql data-lang=sql><span class=k>create</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>sequence_table</span><span class=w>  
</span><span class=w></span><span class=p>(</span><span class=w>  
</span><span class=w>    </span><span class=n>id</span><span class=w>    </span><span class=nb>integer</span><span class=w> </span><span class=k>primary</span><span class=w> </span><span class=k>key</span><span class=p>,</span><span class=w>  
</span><span class=w>    </span><span class=n>name</span><span class=w>  </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w>  </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>  
</span><span class=w>    </span><span class=n>ts</span><span class=w>    </span><span class=k>timestamp</span><span class=w>    </span><span class=k>default</span><span class=w> </span><span class=n>now</span><span class=p>()</span><span class=w>  
</span><span class=w></span><span class=p>);</span><span class=w>  
</span><span class=w>  
</span><span class=w></span><span class=k>create</span><span class=w> </span><span class=n>sequence</span><span class=w> </span><span class=n>sequence_id_auto_gen</span><span class=w> </span><span class=k>increment</span><span class=w> </span><span class=mi>100</span><span class=p>;</span><span class=w>
</span></code></pre></div><h3 id=sequenceentity>SequenceEntity</h3><p>Параметр <code>allocationSize</code> указывает количество айдишников, которые будут сгенерированы за один запрос к к последовательности <code>sequence_id_auto_gen</code> в БД. Размер это параметра прямо влияет на производительность батчевой вставки, подробности в разделе с результатами.</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@Entity</span>  
<span class=nd>@Table</span><span class=o>(</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;sequence_table&#34;</span><span class=o>)</span>  
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>SequenceEntity</span> <span class=o>{</span>  
  <span class=nd>@Id</span>  
  <span class=nd>@SequenceGenerator</span><span class=o>(</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;sequence_id_auto_gen&#34;</span><span class=o>,</span> <span class=n>allocationSize</span> <span class=o>=</span> <span class=n>100</span><span class=o>)</span>  
  <span class=nd>@GeneratedValue</span><span class=o>(</span><span class=n>strategy</span> <span class=o>=</span> <span class=n>GenerationType</span><span class=o>.</span><span class=na>SEQUENCE</span><span class=o>,</span> <span class=n>generator</span> <span class=o>=</span> <span class=s>&#34;sequence_id_auto_gen&#34;</span><span class=o>)</span>  
  <span class=kd>private</span> <span class=n>Integer</span> <span class=n>id</span><span class=o>;</span>  
  
  <span class=kd>private</span> <span class=n>String</span> <span class=n>name</span><span class=o>;</span>  
  
  <span class=kd>private</span> <span class=n>Instant</span> <span class=n>ts</span><span class=o>;</span>  
<span class=o>}</span>
</code></pre></div><h3 id=sequencerepository>SequenceRepository</h3><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@Repository</span>  
<span class=kd>public</span> <span class=kd>interface</span> <span class=nc>SequenceRepository</span> <span class=kd>extends</span> <span class=n>JpaRepository</span><span class=o>&lt;</span><span class=n>SequenceEntity</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>  
<span class=o>}</span>
</code></pre></div><h3 id=тесты>Тесты</h3><p>Первый тест, размер батча установлен в 100, количество записей которые сохраняются в бд установлено в 1000.</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@SpringBootTest</span>  
<span class=kd>class</span> <span class=nc>SequenceRepositoryBatchTest</span> <span class=o>{</span>  
  
  <span class=nd>@Autowired</span>  
  <span class=kd>private</span> <span class=n>SequenceRepository</span> <span class=n>repository</span><span class=o>;</span>  
  
  <span class=nd>@Test</span>  
  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>test1</span><span class=o>()</span> <span class=o>{</span>  
    <span class=kt>long</span> <span class=n>size</span> <span class=o>=</span> <span class=n>1000</span><span class=o>;</span>  
    <span class=n>List</span><span class=o>&lt;</span><span class=n>SequenceEntity</span><span class=o>&gt;</span> <span class=n>sequenceEntities</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>  
  
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=n>1</span><span class=o>)</span> <span class=o>{</span>  
      <span class=n>SequenceEntity</span> <span class=n>entity</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SequenceEntity</span><span class=o>();</span>  
      <span class=n>entity</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;Test identity number: &#34;</span> <span class=o>+</span> <span class=n>i</span><span class=o>);</span>  
      <span class=n>entity</span><span class=o>.</span><span class=na>setTs</span><span class=o>(</span><span class=n>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>  
      <span class=n>sequenceEntities</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>entity</span><span class=o>);</span>  
    <span class=o>}</span>  
  
    <span class=n>repository</span><span class=o>.</span><span class=na>saveAll</span><span class=o>(</span><span class=n>sequenceEntities</span><span class=o>);</span>  
    <span class=n>assertEquals</span><span class=o>(</span><span class=n>size</span><span class=o>,</span> <span class=n>repository</span><span class=o>.</span><span class=na>count</span><span class=o>());</span>  
  <span class=o>}</span>  
<span class=o>}</span>
</code></pre></div><p>Результаты при <code>allocationSize = 10</code></p><pre><code>4588674 nanoseconds spent preparing 101 JDBC statements;
215632040 nanoseconds spent executing 100 JDBC statements;
41919958 nanoseconds spent executing 1 JDBC batches;
194059063 nanoseconds spent executing 1 flushes (flushing a total of 1000 entities and 0 collections);

</code></pre><p>Результаты при <code>allocationSize = 50</code></p><pre><code>930578 nanoseconds spent preparing 21 JDBC statements;
33927601 nanoseconds spent executing 20 JDBC statements;
45626454 nanoseconds spent executing 1 JDBC batches;
176865388 nanoseconds spent executing 1 flushes (flushing a total of 1000 entities and 0 collections);
</code></pre><p>Результаты при <code>allocationSize = 100</code></p><pre><code>766926 nanoseconds spent preparing 11 JDBC statements;
40908813 nanoseconds spent executing 10 JDBC statements;
53419380 nanoseconds spent executing 1 JDBC batches;
214674739 nanoseconds spent executing 1 flushes (flushing a total of 1000 entities and 0 collections);
</code></pre><p>Из лога можно сделать два вывода:</p><ol><li>Батчевая вставка действительно работает.</li><li>Количество запросов к БД зависит от трех параметров:<ol><li>Количества сущностей на вставку</li><li>Размера батча</li><li>Параметра <code>allocationSize</code>, т.е. количества идентификаторов, которые генерируются за один запрос к <code>sequence</code> в БД</li></ol></li></ol><p>Теперь рассмотрим откуда берется такое количество запросов к БД на примере первого лога.
Параметр <code>allocationSize</code> установлен в значение 10, следовательно нужно сделать 1000/10 = 100 запросов к БД что бы сгенерировать 1000 идентификаторов. А затем еще один запрос к БД что бы сохранить батч из 1000 сущностей. В итоге мы получаем 100 + 1 запросов к БД. Но почему батч всего один и на 1000 сущностей? При размере батча в 100 из 1000 сущностей мы должны были получить 10 батчей, следовательно 10 батчевых запросов на вставку.</p><p>Как можно видеть в коде теста, я сначала генерирую 1000 сущностей, затем сохраняю их разом в БД. Судя по всему hibernate не делит их на отдельные батчи по 100 сущностей, а сразу сохраняет одним батчем в 1000 сущностей. Что бы проверить эту теорию я написал еще один тест:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@Test</span>
<span class=kd>public</span> <span class=kt>void</span> <span class=nf>test2</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>10</span><span class=o>;</span> <span class=n>k</span> <span class=o>+=</span> <span class=n>1</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>List</span><span class=o>&lt;</span><span class=n>SequenceEntity</span><span class=o>&gt;</span> <span class=n>sequenceEntities</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>100</span><span class=o>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=n>1</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>SequenceEntity</span> <span class=n>entity</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SequenceEntity</span><span class=o>();</span>
            <span class=n>entity</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;Test identity number: &#34;</span> <span class=o>+</span> <span class=o>(</span><span class=n>k</span> <span class=o>+</span> <span class=n>i</span><span class=o>));</span>
            <span class=n>entity</span><span class=o>.</span><span class=na>setTs</span><span class=o>(</span><span class=n>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
            <span class=n>sequenceEntities</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>entity</span><span class=o>);</span>
        <span class=o>}</span>
        <span class=n>repository</span><span class=o>.</span><span class=na>saveAll</span><span class=o>(</span><span class=n>sequenceEntities</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=n>assertEquals</span><span class=o>(</span><span class=n>1000</span><span class=o>,</span> <span class=n>repository</span><span class=o>.</span><span class=na>count</span><span class=o>());</span>
<span class=o>}</span>
</code></pre></div><p>В результате запуска теста при <code>allocationSize = 10</code> мы видим 10 подобных записей в логе:</p><pre><code>638321 nanoseconds spent preparing 11 JDBC statements;
26781131 nanoseconds spent executing 10 JDBC statements;
7646157 nanoseconds spent executing 1 JDBC batches;
45586938 nanoseconds spent executing 1 flushes (flushing a total of 100 entities and 0 collections);
</code></pre><p>Следовательно, предыдущая теория подтверждена, при передаче N записей в метод <code>saveAll</code> hibernate не делит их на отдельные саб-батчи, а сохраняет все разом. Тогда возникает следующий вопрос, что будет если передать меньше сущностей чем установленно в настройке <code>batch_size</code>? Я написал третий тест что бы это выяснить:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@Test</span>
<span class=kd>public</span> <span class=kt>void</span> <span class=nf>test3</span><span class=o>()</span> <span class=o>{</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>20</span><span class=o>;</span> <span class=n>k</span> <span class=o>+=</span> <span class=n>1</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>List</span><span class=o>&lt;</span><span class=n>SequenceEntity</span><span class=o>&gt;</span> <span class=n>sequenceEntities</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>50</span><span class=o>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=n>1</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>SequenceEntity</span> <span class=n>entity</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SequenceEntity</span><span class=o>();</span>
            <span class=n>entity</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;Test identity number: &#34;</span> <span class=o>+</span> <span class=o>(</span><span class=n>k</span> <span class=o>+</span> <span class=n>i</span><span class=o>));</span>
            <span class=n>entity</span><span class=o>.</span><span class=na>setTs</span><span class=o>(</span><span class=n>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
            <span class=n>sequenceEntities</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>entity</span><span class=o>);</span>
        <span class=o>}</span>
        <span class=n>repository</span><span class=o>.</span><span class=na>saveAll</span><span class=o>(</span><span class=n>sequenceEntities</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=n>assertEquals</span><span class=o>(</span><span class=n>1000</span><span class=o>,</span> <span class=n>repository</span><span class=o>.</span><span class=na>count</span><span class=o>());</span>
<span class=o>}</span>
</code></pre></div><p>В результате запуска теста при <code>allocationSize = 10</code> мы видим 20 подобных записей в логе:</p><pre><code>260032 nanoseconds spent preparing 6 JDBC statements;
8648810 nanoseconds spent executing 5 JDBC statements;
3471284 nanoseconds spent executing 1 JDBC batches;
15285352 nanoseconds spent executing 1 flushes (flushing a total of 50 entities and 0 collections);
</code></pre><p>Как видно из логов теперь размер батча равен 50, ровно столько я и передаю в метод <code>saveAll</code> в третьем тесте.
Из этого можно сделать вывод, что в случае использования метода <code>saveAll</code>, параметр <code>batch_size</code> игнорируется и размер батча равен количеству сущностей, которое передается в метод <code>saveAll</code>.</p><p>Осталось проверить какой будет размер батча, если сохранять сущности через метод <code>save</code> по одной. Для этого я написал четвертый тест:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@Test</span>
<span class=kd>public</span> <span class=kt>void</span> <span class=nf>test4</span><span class=o>()</span> <span class=o>{</span>
    <span class=kt>long</span> <span class=n>size</span> <span class=o>=</span> <span class=n>1000</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=n>1</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>SequenceEntity</span> <span class=n>entity</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SequenceEntity</span><span class=o>();</span>
        <span class=n>entity</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;Test identity number: &#34;</span> <span class=o>+</span> <span class=n>i</span><span class=o>);</span>
        <span class=n>entity</span><span class=o>.</span><span class=na>setTs</span><span class=o>(</span><span class=n>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
        <span class=n>repository</span><span class=o>.</span><span class=na>save</span><span class=o>(</span><span class=n>entity</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=n>assertEquals</span><span class=o>(</span><span class=n>size</span><span class=o>,</span> <span class=n>repository</span><span class=o>.</span><span class=na>count</span><span class=o>());</span>
<span class=o>}</span>
</code></pre></div><p>В результате запуска теста при <code>allocationSize = 10</code> мы получаем 1000 подобных записей в логе:</p><pre><code>12684 nanoseconds spent preparing 2 JDBC statements;
1794385 nanoseconds spent executing 1 JDBC statements;
1466591 nanoseconds spent executing 1 JDBC batches;
1788887 nanoseconds spent executing 1 flushes (flushing a total of 1 entities and 0 collections);
...
21034 nanoseconds spent preparing 1 JDBC statements;
0 nanoseconds spent executing 0 JDBC statements;
1222957 nanoseconds spent executing 1 JDBC batches;
1572550 nanoseconds spent executing 1 flushes (flushing a total of 1 entities and 0 collections);
</code></pre><p>Из анализа этого лога видно следующее:</p><ol><li>Размер батча 1 сущность, нет агрегации запросов в батчи по 100 штук, как указано в конфиге</li><li>hibernate сначала делает запрос на получение 10 идентификаторов, затем последовательно использует их для вставки записей, пока не вставит 10 записей, затем он запрашивает еще 10 идентификаторов и т.д.</li></ol><h2 id=вывод>Вывод</h2><p>Думаю не стоит лишний раз писать, что батчевая вставка работает быстрее одиночной вставки, этот вывод мы опустим.</p><p>Целью статьи было исследовать действительно ли при стратегии генерации идентификаторов <code>GenerationType.IDENTITY</code> не работает батчевая вставка. Как можно видеть из результатов - это чистая правда, батчевая вставка не работает в данном случае, даже если она явно включена в настройках. Spring игнорирует эту опцию и не пишет в логи сообщения об этом.</p><p>При использовании стратегии <code>GenerationType.SEQUENCE</code> нужно обращать внимание не только на количество сущностей и размер батча, но и на параметр <code>allocationSize</code>, он так же оказывает влияние на количество запросов к БД. В идеале значение этого параметра должно равняться размеру батча, что бы на весь батч был один запрос в БД на генерацию идентификаторов.</p><p>В случае сохранения коллекции записей через метод <code>saveAll</code>, параметр <code>batch_size</code> игнорируется, а размер батча равен количеству сущностей в передаваемой коллекции. В случае сохранения сущностей по одной через метод <code>save</code>, размер батча равен 1.</p></article><ul class="pager blog-pager"><li class=previous><a href=https://jaitl.pro/russian/2022/01/25/databases-cap/ data-toggle=tooltip data-placement=top title="Согласованность, Репликация и Базы Данных по CAP">&larr; Previous Post</a></li></ul></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=https://github.com/jaitl title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://twitter.com/jaitl title=Twitter><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-twitter fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted"><a href=https://jaitl.pro>Jaitl</a>
&nbsp;&bull;&nbsp;&copy;
2022
&nbsp;&bull;&nbsp;
<a href=https://jaitl.pro>Jaitl's blog</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.83.1</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://jaitl.pro/js/katex.min.js></script><script src=https://jaitl.pro/js/auto-render.min.js></script><script src=https://jaitl.pro/js/jquery.min.js></script><script src=https://jaitl.pro/js/bootstrap.min.js></script><script src=https://jaitl.pro/js/main.js></script><script>renderMathInElement(document.body)</script><script src=https://jaitl.pro/js/photoswipe.min.js></script><script src=https://jaitl.pro/js/photoswipe-ui-default.min.js></script><script src=https://jaitl.pro/js/load-photoswipe.js></script></body></html>