<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Батчевое сохранение данных в Spring Data JPA - Jaitl's blog</title><meta name=description content="В этой статье я исследую стратегии генерации идентификаторов для сущностей на предмет их совместимости с батчевой вставкой в БД. В качестве ORM используется Spring Data JPA, а в качестве БД - PostgreSQL."><meta name=author content="Jaitl"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"Jaitl\u0027s blog","url":"https:\/\/jaitl.pro"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/jaitl.pro"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/jaitl.pro","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/jaitl.pro\/russian\/2022\/12\/26\/spring-data-jpa-batch\/","name":"Батчевое сохранение данных в spring data jpa"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Jaitl"},"headline":"Батчевое сохранение данных в Spring Data JPA","description":"В этой статье я исследую стратегии генерации идентификаторов для сущностей на предмет их совместимости с батчевой вставкой в БД. В качестве ORM используется Spring Data JPA, а в качестве БД - PostgreSQL.\n","inLanguage":"en","wordCount":2012,"datePublished":"2022-12-26T12:00:00","dateModified":"2022-12-26T12:00:00","image":"https:\/\/jaitl.pro\/img\/jaitl-avatar.png","keywords":[""],"mainEntityOfPage":"https:\/\/jaitl.pro\/russian\/2022\/12\/26\/spring-data-jpa-batch\/","publisher":{"@type":"Organization","name":"https:\/\/jaitl.pro","logo":{"@type":"ImageObject","url":"https:\/\/jaitl.pro\/img\/jaitl-avatar.png","height":60,"width":60}}}</script><meta property="og:title" content="Батчевое сохранение данных в Spring Data JPA"><meta property="og:description" content="В этой статье я исследую стратегии генерации идентификаторов для сущностей на предмет их совместимости с батчевой вставкой в БД. В качестве ORM используется Spring Data JPA, а в качестве БД - PostgreSQL."><meta property="og:image" content="https://jaitl.pro/img/jaitl-avatar.png"><meta property="og:url" content="https://jaitl.pro/russian/2022/12/26/spring-data-jpa-batch/"><meta property="og:type" content="website"><meta property="og:site_name" content="Jaitl's blog"><meta name=twitter:title content="Батчевое сохранение данных в Spring Data JPA"><meta name=twitter:description content="В этой статье я исследую стратегии генерации идентификаторов для сущностей на предмет их совместимости с батчевой вставкой в БД. В качестве ORM используется Spring Data JPA, а в качестве БД - …"><meta name=twitter:image content="https://jaitl.pro/img/jaitl-avatar.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@jaitl"><meta name=twitter:creator content="@jaitl"><link href=https://jaitl.pro/img/favicon.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.111.3"><link rel=alternate href=https://jaitl.pro/index.xml type=application/rss+xml title="Jaitl's blog"><link rel=stylesheet href=https://jaitl.pro/css/katex.min.css><link rel=stylesheet href=https://jaitl.pro/fontawesome/css/all.css><link rel=stylesheet href=https://jaitl.pro/css/bootstrap.min.css><link rel=stylesheet href=https://jaitl.pro/css/main.css><link rel=stylesheet href=https://jaitl.pro/css/fonts.css><link rel=stylesheet href=https://jaitl.pro/css/syntax.css><link rel=stylesheet href=https://jaitl.pro/css/codeblock.css><link rel=stylesheet href=https://jaitl.pro/css/photoswipe.min.css><link rel=stylesheet href=https://jaitl.pro/css/photoswipe.default-skin.min.css><script async src="https://www.googletagmanager.com/gtag/js?id=G-KBJ7QRKR1F"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KBJ7QRKR1F",{anonymize_ip:!1})}</script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=https://jaitl.pro>Jaitl's blog</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=Notes href=/notes>Notes</a></li><li><a title=Telegram href=https://t.me/seniorsITBlog>Telegram</a></li><li><a title=About href=/about>About</a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="Jaitl's blog" href=https://jaitl.pro><img class=avatar-img src=https://jaitl.pro/img/jaitl-avatar.png alt="Jaitl's blog"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-10 col-lg-offset-1 col-md-10 col-md-offset-1"><div class=post-heading><h1>Батчевое сохранение данных в Spring Data JPA</h1><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on December 26, 2022
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;10&nbsp;minutes
&nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;2012&nbsp;words
&nbsp;|&nbsp;<i class="fas fa-user"></i>&nbsp;Jaitl</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-10 col-lg-offset-1 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>В этой статье я исследую стратегии генерации идентификаторов для сущностей на предмет их совместимости с батчевой вставкой в БД. В качестве ORM используется Spring Data JPA, а в качестве БД - PostgreSQL.</p><p>Я провел теоретическое исследование в результате которого выяснилось, что для батчевой вставки (batch insert) данных идентификаторы должны генерироваться с использованием стратегии <code>GenerationType.SEQUENCE</code>, которая в свою очередь использует отдельную сущность в БД под названием <a href=https://www.postgresql.org/docs/10/sql-createsequence.html>sequence</a> для батчевой генерации идентификаторов (<code>primary key</code>).</p><p>Теоретическое исследование статей в интернете показывает, что стратегия <code>GenerationType.IDENTITY</code> позволяющая использовать стандартный тип <code>serial</code> для авто-генерации идентификаторов не работает с батчевой вставкой. Судя по документации в случае <code>GenerationType.IDENTITY</code> Spring игнорирует батчевую вставку даже если она включена в настройках.</p><blockquote><p>When we want to use batching for inserts, we should be aware of the primary key generation strategy. If our entities use the GenerationType.IDENTITY identifier generator, Hibernate will silently disable batch inserts.</p></blockquote><p><a href=https://www.baeldung.com/jpa-hibernate-batch-insert-update#id-generation-strategy>baeldung.com</a></p><p>Я не люблю плодить дополнительные сущности и хотел бы дальше использовать тип <code>serial</code> для идентификаторов не создавая дополнительно сущность <code>sequence</code>, поэтому в этой статье я хочу провести практическое исследование и выяснить возможно ли использовать стратегию <code>GenerationType.IDENTITY</code> для генерирования идентификаторов при батчевой вставке.</p><h2 id=включение-батчевой-вставки-и-логирования-запросов>Включение батчевой вставки и логирования запросов</h2><p><a href=https://github.com/jaitl/spring-jpa-batch-insert/blob/main/src/main/resources/application.yml>application.yml</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>spring</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>jpa</span><span class=p>:</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>properties</span><span class=p>:</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>hibernate</span><span class=p>:</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>generate_statistics</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>order_inserts</span><span class=p>:</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>jdbc.batch_size</span><span class=p>:</span><span class=w> </span><span class=m>100</span><span class=w>
</span></span></span></code></pre></div><p>Флаги:</p><ul><li><code>generate_statistics</code> - включает генерирование статистики о запросах на уровне <code>Hibernate</code></li><li><code>order_inserts</code> - включает сортировку запросов по имени таблицы. В случае если инсерты не отсортированы по имени таблицы, они не могут быть объеденины в один батч и будут разделены на несколько батчей</li><li><code>batch_size</code> - размер батча</li></ul><p>Для более точного логирования я использую библиотеку <a href=https://github.com/jdbc-observations/datasource-proxy>datasource-proxy</a>, которая оборачивает спринговый <code>datasource</code> в <code>datasource-proxy</code> и логирует запросы на уровне драйвера. Настраивается эта библиотека с помощью <a href=https://github.com/jaitl/spring-jpa-batch-insert/blob/main/src/main/java/pro/jaitl/spring/jpa/batch/log/DatasourceProxyBeanPostProcessor.java>DatasourceProxyBeanPostProcessor</a>.</p><h2 id=generationtypeidentity>GenerationType.IDENTITY</h2><p>Начнем эксперимент со стратегии <code>GenerationType.IDENTITY</code>. Ниже приведен sql код создания таблицы для сущности, код сущности, репозитория и теста, полный код можно найти на <a href=https://github.com/jaitl/spring-jpa-batch-insert>Github</a>.</p><h3 id=sql-код-таблицы>SQL код таблицы</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>create</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>identity_table</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>(</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w>    </span><span class=nb>serial</span><span class=w>        </span><span class=k>primary</span><span class=w> </span><span class=k>key</span><span class=p>,</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>name</span><span class=w>  </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w>  </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ts</span><span class=w>    </span><span class=k>timestamp</span><span class=w>     </span><span class=k>default</span><span class=w> </span><span class=n>now</span><span class=p>()</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h3 id=identityentity>IdentityEntity</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Entity</span>
</span></span><span class=line><span class=cl><span class=nd>@Table</span><span class=o>(</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;identity_table&#34;</span><span class=o>)</span>  
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>IdentityEntity</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>  <span class=nd>@Id</span>  
</span></span><span class=line><span class=cl>  <span class=nd>@GeneratedValue</span><span class=o>(</span><span class=n>strategy</span> <span class=o>=</span> <span class=n>GenerationType</span><span class=o>.</span><span class=na>IDENTITY</span><span class=o>)</span>  
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>Integer</span> <span class=n>id</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>String</span> <span class=n>name</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>Instant</span> <span class=n>ts</span><span class=o>;</span>  
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=identityrepository>IdentityRepository</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Repository</span>  
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>IdentityRepository</span> <span class=kd>extends</span> <span class=n>JpaRepository</span><span class=o>&lt;</span><span class=n>IdentityEntity</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>  <span class=o>}</span>
</span></span></code></pre></div><h3 id=тест>Тест</h3><p>Размер батча установлен в 100, количество записей которые сохраняются в бд - 1000.</p><p><a href=https://github.com/jaitl/spring-jpa-batch-insert/blob/main/src/test/java/pro/jaitl/spring/jpa/batch/IdentityRepositoryBatchTest.java>Код теста</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@SpringBootTest</span>  
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>IdentityRepositoryBatchTest</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nd>@Autowired</span>  
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>IdentityRepository</span> <span class=n>repository</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nd>@Test</span>  
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>()</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>size</span> <span class=o>=</span> <span class=mi>1000</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>IdentityEntity</span><span class=o>&gt;</span> <span class=n>identityEntities</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>      <span class=n>IdentityEntity</span> <span class=n>entity</span> <span class=o>=</span> <span class=k>new</span> <span class=n>IdentityEntity</span><span class=o>();</span>  
</span></span><span class=line><span class=cl>      <span class=n>entity</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;Test identity number: &#34;</span> <span class=o>+</span> <span class=n>i</span><span class=o>);</span>  
</span></span><span class=line><span class=cl>      <span class=n>entity</span><span class=o>.</span><span class=na>setTs</span><span class=o>(</span><span class=n>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>  
</span></span><span class=line><span class=cl>      <span class=n>identityEntities</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>entity</span><span class=o>);</span>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=n>repository</span><span class=o>.</span><span class=na>saveAll</span><span class=o>(</span><span class=n>identityEntities</span><span class=o>);</span>  
</span></span><span class=line><span class=cl>    <span class=n>assertEquals</span><span class=o>(</span><span class=n>size</span><span class=o>,</span> <span class=n>repository</span><span class=o>.</span><span class=na>count</span><span class=o>());</span>  
</span></span><span class=line><span class=cl>  <span class=o>}</span>  
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Лог с результатом от <code>Hibernate</code>:</p><pre tabindex=0><code>114701 nanoseconds spent preparing 1 JDBC statements;
1995614 nanoseconds spent executing 1 JDBC statements;
0 nanoseconds spent executing 0 JDBC batches;
</code></pre><p>Лог с результатом от <code>datasource-proxy</code>:</p><pre tabindex=0><code>Type:Prepared, Batch:False, QuerySize:1, BatchSize:0
Query:[&#34;insert into identity_table (name, ts) values (?, ?)&#34;]
Params:[(Test identity number: 0,2022-12-27 11:01:20.637046)]
</code></pre><p>Как можно видеть из логов, приложением было выполнено 1000 запросов в БД, а количество батчей - 0. Следовательно, батчевые вставки не выполняются в случае стратегии <code>GenerationType.IDENTITY</code> и документация не врет (ну а вдруг бы врала, всякое бывает).</p><h2 id=generationtypesequence>GenerationType.SEQUENCE</h2><p>Теперь перейдем к стратегии <code>GenerationType.SEQUENCE</code>. Ниже приведен sql код создания таблицы для сущности, код сущности, репозитория и теста, полный код можно найти на <a href=https://github.com/jaitl/spring-jpa-batch-insert>Github</a>.</p><h3 id=sql-код-таблицы-1>SQL код таблицы</h3><p>Как можно заметить тип поля идентификатора - <code>integer</code>, потому что для инкрементальной генерации идентификаторов <code>Hibernate</code> будет использовать последовательность <code>sequence_id_auto_gen</code>, следовательно тип <code>serial</code> для идентификатора ненужен.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>create</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>sequence_table</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>(</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span><span class=w>    </span><span class=nb>integer</span><span class=w>       </span><span class=k>primary</span><span class=w> </span><span class=k>key</span><span class=p>,</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>name</span><span class=w>  </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span><span class=w>  </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ts</span><span class=w>    </span><span class=k>timestamp</span><span class=w>     </span><span class=k>default</span><span class=w> </span><span class=n>now</span><span class=p>()</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>create</span><span class=w> </span><span class=n>sequence</span><span class=w> </span><span class=n>sequence_id_auto_gen</span><span class=w> </span><span class=k>increment</span><span class=w> </span><span class=mi>100</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>Последовательность <code>sequence_id_auto_gen</code> имеет параметр <code>increment</code>, который должен быть согласован с параметром <code>allocationSize</code> из аннотации <code>@SequenceGenerator</code>.</p><h3 id=sequenceentity>SequenceEntity</h3><p>Параметр <code>allocationSize</code> указывает количество идентификаторов, которые будут сгенерированы за один запрос в БД к последовательности <code>sequence_id_auto_gen</code>. Размер это параметра прямо влияет на производительность батчевой вставки, исследование ниже.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Entity</span>  
</span></span><span class=line><span class=cl><span class=nd>@Table</span><span class=o>(</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;sequence_table&#34;</span><span class=o>)</span>  
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SequenceEntity</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>  <span class=nd>@Id</span>  
</span></span><span class=line><span class=cl>  <span class=nd>@SequenceGenerator</span><span class=o>(</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;sequence_id_auto_gen&#34;</span><span class=o>,</span> <span class=n>allocationSize</span> <span class=o>=</span> <span class=mi>100</span><span class=o>)</span>  
</span></span><span class=line><span class=cl>  <span class=nd>@GeneratedValue</span><span class=o>(</span><span class=n>strategy</span> <span class=o>=</span> <span class=n>GenerationType</span><span class=o>.</span><span class=na>SEQUENCE</span><span class=o>,</span> <span class=n>generator</span> <span class=o>=</span> <span class=s>&#34;sequence_id_auto_gen&#34;</span><span class=o>)</span>  
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>Integer</span> <span class=n>id</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>String</span> <span class=n>name</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>Instant</span> <span class=n>ts</span><span class=o>;</span>  
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=sequencerepository>SequenceRepository</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Repository</span>  
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>SequenceRepository</span> <span class=kd>extends</span> <span class=n>JpaRepository</span><span class=o>&lt;</span><span class=n>SequenceEntity</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>  <span class=o>}</span>
</span></span></code></pre></div><h3 id=тесты>Тесты</h3><h4 id=первый-тест-размер-батча-100-количество-записей-1000-вставляется-сразу-1000-сущностей>Первый тест: размер батча 100, количество записей 1000, вставляется сразу 1000 сущностей</h4><p><a href=https://github.com/jaitl/spring-jpa-batch-insert/blob/main/src/test/java/pro/jaitl/spring/jpa/batch/SequenceRepositoryBatchTest.java>Код тестов</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@SpringBootTest</span>  
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>SequenceRepositoryBatchTest</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nd>@Autowired</span>  
</span></span><span class=line><span class=cl>  <span class=kd>private</span> <span class=n>SequenceRepository</span> <span class=n>repository</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=nd>@Test</span>  
</span></span><span class=line><span class=cl>  <span class=kd>public</span> <span class=kt>void</span> <span class=nf>test1</span><span class=o>()</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>size</span> <span class=o>=</span> <span class=mi>1000</span><span class=o>;</span>  
</span></span><span class=line><span class=cl>    <span class=n>List</span><span class=o>&lt;</span><span class=n>SequenceEntity</span><span class=o>&gt;</span> <span class=n>sequenceEntities</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>  
</span></span><span class=line><span class=cl>      <span class=n>SequenceEntity</span> <span class=n>entity</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SequenceEntity</span><span class=o>();</span>  
</span></span><span class=line><span class=cl>      <span class=n>entity</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;Test identity number: &#34;</span> <span class=o>+</span> <span class=n>i</span><span class=o>);</span>  
</span></span><span class=line><span class=cl>      <span class=n>entity</span><span class=o>.</span><span class=na>setTs</span><span class=o>(</span><span class=n>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>  
</span></span><span class=line><span class=cl>      <span class=n>sequenceEntities</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>entity</span><span class=o>);</span>  
</span></span><span class=line><span class=cl>    <span class=o>}</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=n>repository</span><span class=o>.</span><span class=na>saveAll</span><span class=o>(</span><span class=n>sequenceEntities</span><span class=o>);</span>  
</span></span><span class=line><span class=cl>    <span class=n>assertEquals</span><span class=o>(</span><span class=n>size</span><span class=o>,</span> <span class=n>repository</span><span class=o>.</span><span class=na>count</span><span class=o>());</span>  
</span></span><span class=line><span class=cl>  <span class=o>}</span>  
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Результаты при <code>allocationSize = 10</code></p><p>Логи от <code>Hibernate</code>:</p><pre tabindex=0><code>9654469 nanoseconds spent preparing 102 JDBC statements;
243283459 nanoseconds spent executing 101 JDBC statements;
99123235 nanoseconds spent executing 10 JDBC batches;
311794956 nanoseconds spent executing 1 flushes (flushing a total of 1000 entities and 0 collections);
</code></pre><p>Логи от <code>datasource-proxy</code>:</p><pre tabindex=0><code>Name:MyDS, Connection:7, Time:12, Success:True
Type:Prepared, Batch:True, QuerySize:1, BatchSize:100
Query:[&#34;insert into sequence_table (name, ts, id) values (?, ?, ?)&#34;]
</code></pre><p>Результаты при <code>allocationSize = 50</code></p><p>Логи от <code>Hibernate</code>:</p><pre tabindex=0><code>2575582 nanoseconds spent preparing 22 JDBC statements;
64088523 nanoseconds spent executing 21 JDBC statements;
166666099 nanoseconds spent executing 10 JDBC batches;
479391860 nanoseconds spent executing 1 flushes (flushing a total of 1000 entities and 0 collections);
</code></pre><p>Логи от <code>datasource-proxy</code>:</p><pre tabindex=0><code>Name:MyDS, Connection:7, Time:13, Success:True
Type:Prepared, Batch:True, QuerySize:1, BatchSize:100
Query:[&#34;insert into sequence_table (name, ts, id) values (?, ?, ?)&#34;]
</code></pre><p>Результаты при <code>allocationSize = 100</code></p><p>Логи от <code>Hibernate</code>:</p><pre tabindex=0><code>1226502 nanoseconds spent preparing 12 JDBC statements;
45371272 nanoseconds spent executing 11 JDBC statements;
81173417 nanoseconds spent executing 10 JDBC batches;
280084078 nanoseconds spent executing 1 flushes (flushing a total of 1000 entities and 0 collections);
</code></pre><p>Логи от <code>datasource-proxy</code>:</p><pre tabindex=0><code>Name:MyDS, Connection:7, Time:6, Success:True
Type:Prepared, Batch:True, QuerySize:1, BatchSize:100
Query:[&#34;insert into sequence_table (name, ts, id) values (?, ?, ?)&#34;]
</code></pre><p>Из лога можно сделать два вывода:</p><ol><li>Батчевая вставка действительно работает.</li><li>Количество запросов к БД зависит от трех параметров:<ol><li>Количества сущностей на вставку.</li><li>Размера батча.</li><li>Параметра <code>allocationSize</code>, т.е. количества идентификаторов, которые генерируются за один запрос в БД к <code>sequence_id_auto_gen</code>.</li></ol></li></ol><p>Теперь рассмотрим откуда берется 101 + 10 запросов к БД на примере лога первого результата:</p><ol><li><code>Hibernate</code> делает 1 запрос к <code>sequence_id_auto_gen</code> что бы получить текущее значение последовательности.</li><li>Параметр <code>allocationSize</code> установлен в значение 10, следовательно выполняется 1000/10 = 100 запросов к БД что бы сгенерировать 1000 идентификаторов по 10 идентификаторов за запрос.</li><li>Параметр <code>batch_size</code> установлен в 100, следовательно выполняется 10 батчевых запросов по 100 сущностей в каждом, что бы сохранить батч из 1000 сущностей.</li></ol><p>В итоге мы получаем 1 + 100 + 10 = 111 запросов к БД.</p><h4 id=второй-тест-размер-батча-100-количество-записей-1000-вставляются-по-100-сущностей-за-раз>Второй тест: размер батча 100, количество записей 1000, вставляются по 100 сущностей за раз</h4><p>Как можно видеть в коде первого теста, я сначала генерирую 1000 сущностей, затем сохраняю их разом в БД, а <code>Hibernate</code> сам делит их на 10 батчей по 100 сущностей. Во втором тесте я генерирую и сохраняю по 100 сущностей за раз.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test2</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=o>;</span> <span class=n>k</span> <span class=o>+=</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>SequenceEntity</span><span class=o>&gt;</span> <span class=n>sequenceEntities</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=o>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>SequenceEntity</span> <span class=n>entity</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SequenceEntity</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=n>entity</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;Test identity number: &#34;</span> <span class=o>+</span> <span class=o>(</span><span class=n>k</span> <span class=o>+</span> <span class=n>i</span><span class=o>));</span>
</span></span><span class=line><span class=cl>            <span class=n>entity</span><span class=o>.</span><span class=na>setTs</span><span class=o>(</span><span class=n>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
</span></span><span class=line><span class=cl>            <span class=n>sequenceEntities</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>entity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>repository</span><span class=o>.</span><span class=na>saveAll</span><span class=o>(</span><span class=n>sequenceEntities</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>assertEquals</span><span class=o>(</span><span class=mi>1000</span><span class=o>,</span> <span class=n>repository</span><span class=o>.</span><span class=na>count</span><span class=o>());</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>В результате запуска теста при <code>allocationSize = 100</code> мы видим 10 подобных записей в логе от <code>Hibernate</code>:</p><pre tabindex=0><code>564714 nanoseconds spent preparing 3 JDBC statements;
5325416 nanoseconds spent executing 2 JDBC statements;
12250282 nanoseconds spent executing 1 JDBC batches;
75982849 nanoseconds spent executing 1 flushes (flushing a total of 100 entities and 0 collections);
</code></pre><p>А так же 10 подобных записей в логе от <code>datasource-proxy</code>:</p><pre tabindex=0><code>Name:MyDS, Connection:7, Time:9, Success:True
Type:Prepared, Batch:True, QuerySize:1, BatchSize:100
Query:[&#34;insert into sequence_table (name, ts, id) values (?, ?, ?)&#34;]
</code></pre><p>Из анализа логов следует что мы так же получаем 10 батчей по 100 сущностей в каждом.</p><h4 id=третий-тест-размер-батча-100-количество-записей-1000-вставляются-по-50-сущностей-за-раз>Третий тест: размер батча 100, количество записей 1000, вставляются по 50 сущностей за раз</h4><p>В третьем тесте я решил проверить, что будет если передать меньше сущностей чем установленно в настройке <code>batch_size</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test3</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=mi>20</span><span class=o>;</span> <span class=n>k</span> <span class=o>+=</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>List</span><span class=o>&lt;</span><span class=n>SequenceEntity</span><span class=o>&gt;</span> <span class=n>sequenceEntities</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>50</span><span class=o>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>SequenceEntity</span> <span class=n>entity</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SequenceEntity</span><span class=o>();</span>
</span></span><span class=line><span class=cl>            <span class=n>entity</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;Test identity number: &#34;</span> <span class=o>+</span> <span class=o>(</span><span class=n>k</span> <span class=o>+</span> <span class=n>i</span><span class=o>));</span>
</span></span><span class=line><span class=cl>            <span class=n>entity</span><span class=o>.</span><span class=na>setTs</span><span class=o>(</span><span class=n>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
</span></span><span class=line><span class=cl>            <span class=n>sequenceEntities</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>entity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>repository</span><span class=o>.</span><span class=na>saveAll</span><span class=o>(</span><span class=n>sequenceEntities</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>assertEquals</span><span class=o>(</span><span class=mi>1000</span><span class=o>,</span> <span class=n>repository</span><span class=o>.</span><span class=na>count</span><span class=o>());</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>В результате запуска теста при <code>allocationSize = 100</code> мы видим 20 подобных записей в логе от <code>Hibernate</code>:</p><pre tabindex=0><code>309752 nanoseconds spent preparing 3 JDBC statements;
3794706 nanoseconds spent executing 2 JDBC statements;
7992646 nanoseconds spent executing 1 JDBC batches;
15285352 nanoseconds spent executing 1 flushes (flushing a total of 50 entities and 0 collections);
...
67387 nanoseconds spent preparing 1 JDBC statements;
0 nanoseconds spent executing 0 JDBC statements;
4282457 nanoseconds spent executing 1 JDBC batches;
15285352 nanoseconds spent executing 1 flushes (flushing a total of 50 entities and 0 collections);
</code></pre><p>А так же 20 подобных записей в логе от <code>datasource-proxy</code>:</p><pre tabindex=0><code>Name:MyDS, Connection:7, Time:6, Success:True
Type:Prepared, Batch:True, QuerySize:1, BatchSize:50
Query:[&#34;insert into sequence_table (name, ts, id) values (?, ?, ?)&#34;]
</code></pre><p>Как видно из логов, теперь размер батча равен 50, ровно столько я и передаю в метод <code>saveAll</code> в третьем тесте. Следовательно, <code>Hibernate</code> не объединяет мелкие батчи в большие для достижения размера батча из параметра <code>batch_size</code>.</p><p>Так же из интересного можно проанализировать запросы к <code>sequence_id_auto_gen</code> на получения идентификаторов:</p><ol><li>В первом логе мы видим два запроса к <code>sequence_id_auto_gen</code>: один на получение начального значения и один на получение 100 идентификаторов.</li><li>Во втором логе мы видим 0 запросов к <code>sequence_id_auto_gen</code>, потому что в первом запросе мы получили 100 идентификаторов, а использовали 50, так как количество сохраняемых сущностей равняется 50, следовательно осталось еще 50 идентификаторов для второго батча и еще один запрос к <code>sequence_id_auto_gen</code> делать ненужно.</li></ol><h4 id=четвертый-тест-сохранение-по-1-записи>Четвертый тест: сохранение по 1 записи</h4><p>Осталось проверить какой будет размер батча, если сохранять сущности через метод <code>save</code> поштучно. Для этого я написал четвертый тест:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test4</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>size</span> <span class=o>=</span> <span class=mi>1000</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>SequenceEntity</span> <span class=n>entity</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SequenceEntity</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>entity</span><span class=o>.</span><span class=na>setName</span><span class=o>(</span><span class=s>&#34;Test identity number: &#34;</span> <span class=o>+</span> <span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>entity</span><span class=o>.</span><span class=na>setTs</span><span class=o>(</span><span class=n>Instant</span><span class=o>.</span><span class=na>now</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>repository</span><span class=o>.</span><span class=na>save</span><span class=o>(</span><span class=n>entity</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=n>assertEquals</span><span class=o>(</span><span class=n>size</span><span class=o>,</span> <span class=n>repository</span><span class=o>.</span><span class=na>count</span><span class=o>());</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>В результате запуска теста при <code>allocationSize = 100</code> мы получаем 1000 подобных записей в логе от <code>Hibernate</code>:</p><pre tabindex=0><code>12684 nanoseconds spent preparing 2 JDBC statements;
1794385 nanoseconds spent executing 1 JDBC statements;
1466591 nanoseconds spent executing 1 JDBC batches;
1788887 nanoseconds spent executing 1 flushes (flushing a total of 1 entities and 0 collections);
...
21034 nanoseconds spent preparing 1 JDBC statements;
0 nanoseconds spent executing 0 JDBC statements;
1222957 nanoseconds spent executing 1 JDBC batches;
1572550 nanoseconds spent executing 1 flushes (flushing a total of 1 entities and 0 collections);
</code></pre><p>А так же 1000 подобных записей в логе от <code>datasource-proxy</code>:</p><pre tabindex=0><code>Name:MyDS, Connection:733, Time:1, Success:True
Type:Prepared, Batch:True, QuerySize:1, BatchSize:1
Query:[&#34;insert into sequence_table (name, ts, id) values (?, ?, ?)&#34;]
</code></pre><p>Из анализа этого лога видно, что размер батча - 1, следовательно агрегации в большие батчи нет.</p><h2 id=вывод>Вывод</h2><p>Думаю не стоит лишний раз писать, что батчевая вставка работает быстрее одиночной вставки, этот вывод мы опустим.</p><p>Статистика от <code>Hibernate</code> соответствует метрикам от <code>datasource-proxy</code>, так что для поверхностного анализа необязательно подключать и настраивать библиотеку <code>datasource-proxy</code>.</p><p>Целью статьи было исследовать действительно ли при стратегии генерации идентификаторов <code>GenerationType.IDENTITY</code> не работает батчевая вставка. Как можно видеть из результатов - это чистая правда. Батчевая вставка не работает в данном случае, даже если она явно включена в настройках. Spring игнорирует эту настройку и не пишет в логи предупреждения об этом.</p><p>При использовании стратегии <code>GenerationType.SEQUENCE</code> следует обращать внимание не только на количество сущностей и размер батча, но и на параметр <code>allocationSize</code>, так как он тоже оказывает влияние на количество запросов к БД. В идеале значение этого параметра должно равняться размеру батча, что бы идентификаторы для всего батча сгенерировались за один запрос в БД к <code>sequence_id_auto_gen</code>.</p><p>При сохранении батча через <code>saveAll</code> видим следующее поведение:</p><ol><li>Если размер батча больше <code>batch_size</code>, то он делится на несколько более мелких батчей по <code>batch_size</code> сущностей в каждом.</li><li>Если размер батча меньше <code>batch_size</code>, то батч не агрегируется в более большой батч, а отправляется в БД в том размере что есть.</li></ol><p>В случае сохранения сущностей по одной через метод <code>save</code> размер батча равен 1, т.е. сущности так же не агрегируются в более большой батч.</p><h2 id=версии>Версии</h2><p>Версии всех зависимостей можно посмотреть в <a href=https://github.com/jaitl/spring-jpa-batch-insert/blob/main/build.gradle>build.gradle</a></p><p>Основные версии:</p><ul><li>PostgreSQL 10</li><li>Spring Boot 2.7.7</li></ul><h2 id=полезные-ссылки>Полезные ссылки:</h2><ul><li><a href=https://github.com/jaitl/spring-jpa-batch-insert>Исходный код примеров</a></li><li><a href=https://www.baeldung.com/jpa-hibernate-batch-insert-update>Batch Insert/Update with Hibernate/JPA</a></li><li><a href=https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#batch>Batching in Hibernate/JPA</a></li></ul></article><ul class="pager blog-pager"><li class=previous><a href=https://jaitl.pro/russian/2022/01/25/databases-cap/ data-toggle=tooltip data-placement=top title="Согласованность, Репликация и Базы Данных по CAP">&larr; Previous Post</a></li><li class=next><a href=https://jaitl.pro/post/2023-04-24-spring-bean-validation-in-practice/ data-toggle=tooltip data-placement=top title="Bean Validation в Spring на практике">Next Post &rarr;</a></li></ul></div></div></div><footer><div class=container><div class=row><div class="col-lg-10 col-lg-offset-1 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=https://github.com/jaitl title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://twitter.com/jaitl title=Twitter><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-twitter fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted"><a href=https://jaitl.pro>Jaitl</a>
&nbsp;&bull;&nbsp;&copy;
2023
&nbsp;&bull;&nbsp;
<a href=https://jaitl.pro>Jaitl's blog</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.111.3</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script src=https://jaitl.pro/js/katex.min.js></script>
<script src=https://jaitl.pro/js/auto-render.min.js></script>
<script src=https://jaitl.pro/js/jquery-3.5.1.slim.min.js></script>
<script src=https://jaitl.pro/js/bootstrap.min.js></script>
<script src=https://jaitl.pro/js/main.js></script><script>renderMathInElement(document.body)</script><script src=https://jaitl.pro/js/photoswipe.min.js></script>
<script src=https://jaitl.pro/js/photoswipe-ui-default.min.js></script><script src=https://jaitl.pro/js/load-photoswipe.js></script></body></html>