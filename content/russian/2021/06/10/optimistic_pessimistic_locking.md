---
title: "Оптимистические и Пессимистические Блокировки"
author: ""
type: ""
date: 2021-06-10T12:00:00+03:00
subtitle: ""
image: ""
tags: []
private: false
---
Краткий обзор оптимистических и пессимистических блокировок.
В этой заметке рассматриваются основные различия этих двух подходов на примере реализации целочисленного счетчика на `Java`.

<!--more-->
Статья из моего telegram канала: [Senior's Blog](https://t.me/seniorsITBlog). Подписывайтесь на канал ;-)

## Блокировки
Блокировки в многопоточной среде необходимы для одновременной работы двух и более потоков с одними и теми же данными.
Блокировки позволяют избежать потери и повреждения данных.
Существуют два подхода к блокировкам: оптимистические и пессимистические.

Суть пессимистических блокировок в эксклюзивном доступе к данным,
т.е. когда один поток получил пессимистическую блокировку на данные, другие потоки не могут читать и изменять эти данные,
пока поток не снимет блокировку.
Пессимистические блокировки достаточно простые в реализации, но обладают очень важным недостатком - дедлоками ([deadlock](https://en.wikipedia.org/wiki/Deadlock)).

Оптимистические блокировки устроены по другому принципу.
Они существуют во многих вариациях, я расскажу про самую простую - [CAS](https://en.wikipedia.org/wiki/Compare-and-swap).
Когда два потока хотят изменить одни и те же данные, потоки копируют эти данные в свою локальную память,
затем меняют их и пытаются отправить измененные данные в основную память.
Перед внесением изменений в основную память проверяется версия данных или предыдущее значение данных. 
Если проверка не проходит, то поток снова копирует к себе уже новые данные,
вносит в них изменения и снова пытается отправить эти измененные данные в основную память.

Оптимистические блокировки иногда называют не блокируемыми ([non-blocking](https://en.wikipedia.org/wiki/Non-blocking_algorithm)), 
потому что при изменении данных поток работает со своей локальной копией данных, 
а данные в основном хранилище остаются открытыми другим потоках для чтения и изменения.

Простой пример оптимистических блокировок с которыми каждый день сталкивается любой разработчик - это системы контроля версий, например Git.
Вы копируете себе ветку с кодом, модифицируете ее и пытаетесь слить с мастером,
если кто-то обновил мастер до вас, вам надо скопировать себе его изменения, исправить конфликты и снова попытаться слить свою ветку с мастером.

[В этой статье](https://vladmihalcea.com/optimistic-vs-pessimistic-locking/) сравниваются эти два вида блокировок на примере баз данных.

## Java
Рассмотрим реализацию оптимистических и пессимистических блокировок в `Java`.
В качестве примера реализуем целочисленный счетчик.

Для пессимистических блокировок наиболее простым решением будет использование блока `synchronized`.

Получаем простенький класс:
```java
public class Counter {
  private int counter;
  public int incrementAndGet() {
    synchronized (this) {
      counter += 1;
      return counter;
    }
  }
  public int get() {
    synchronized (this) {
      return counter;
    }
  }
}
```

Не забываем, что `synchronize` нужен не только при записи но и при чтении счетчика.
И в этом случае `counter` необязательно объявлять как `volatile`,
потому что `synchronized` гарантирует синхронизацию данных в оперативной памяти и в памяти потока при входе в блок.
Если интересна эта тема почитайте про `Happens Before Guarantee`, [например тут](https://dzone.com/articles/difference-between-volatile-and-synchronized-keywo).

Для оптимистических блокировок все уже сделано за нас - это `AtomicInteger`.
Если посмотреть на код `AtomicInteger`, то там обнаружится обычная `volatile` переменная
```java
private volatile int value;
```
И функция которая обновляет эту переменную с помощью `Compare-and-swap (CAS)` алгоритма:
```java
public final native boolean compareAndSetInt(Object o, long offset, int expected, int x);
```
Эта функция будет использовать нативную инструкцию процессора, которая атомарно выполнит сравнение и обновление значения переменной.

Подробнее про реализацию CAS в JVM можно [почитать тут](https://habr.com/ru/post/319036/).
