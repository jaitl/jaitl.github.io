---
title: "Генератоты, Асинхронность, Корутины"
author: ""
type: ""
date: 2021-08-04T12:00:00+03:00
subtitle: ""
image: ""
tags: []
private: false
---
Статья про то что такое генераторы, какая бывает асинхронность и что такое корутины.

<!--more-->
Статья из моего telegram канала: [Senior's Blog](https://t.me/seniorsITBlog). Подписывайтесь на канал ;-)

## Генераторы
Генераторы (`Generators`) достаточно интересная структура которая мало известна в чистой Java. Если вы пишите на Python или Kotlin то вы скорее всего сталкивались с ними.

Generators представляет из себя что то вроде ленивого итератора (lazy iterators) по которому можно проходить циклом получая из него новые элементы. При каждом новом обращении к генератору он выдает новый элемент и после этого “засыпает”. Это засыпание и является основной фишкой генераторов.

Давайте рассмотрим пару применений генераторов.

Первое - это создание бесконечных итераторов, которые не занимают большого количества памяти.

Пример на питоне:
```python
def infinite_sequence():
    num = 0
    while True:
        yield num
        num += 1
```

В котлине есть вспомогательные функции, которые позволяют написать то же самое в одну строчку:

```kotlin
generateSequence(0) { it + 1 }
```

Как видно из примеров бесконечные генераторы не хранят всю сгенерированную последовательность, их состояние - это последний сгенерированный элемент на основе которого они генерируют следующий элемент. В случае питона явно видно ключевое слово `yield` на котором генератор засыпает и ждет следующего обращения к нему.

Второе применение - инкапсуляция запроса и получения данных из какого то источника, например из БД.

```python
def SQL_items():
    cursor = connection.cursor()
    cursor.execute("SELECT ...")
    row = cursor.fetchone()
    while row not None:
        yield row
        row = cursor.fetchone()
```

Делаем запрос к БД, получаем элементы по одному и отдаем их пользователю. Пользователь в любой момент времени может прекратить получение элементов и закрыть генератор. Как видно из примера все элементы в памяти не хранятся, а считываются по мере необходимости.

Генераторы могут быть полезны в нескольких юзкейсах, но больший интерес представляют корутины (Coroutines), которые основаны на генераторах, о них я расскажу в следующем посте.

## Асинхронность
Перед знакомством с корутинами нужно вспомнить что такое асинхронные и не блокируемые IO операции. 

Основы асинхронного программирования всем давно известны, это когда наш основном поток не блокируется на длительное время, все долгие и выполняются в фоне, а основной поток просто дожидается результатов этих долгих операций и во время ожидания он может заниматься чем то полезным.

Обычно долгие операции - это операции ввода\вывода (IO), такие как запросы к БД, запросы к другим сервисам, чтение/запись файлов. Асинхронность этих операций достигается за счет таких подходов как Callbacks, Futures, Actors и т.д.

Асинхронные операции можно разделить на два типа: блокируемые (blocking) и не блокируемые (non-blocking) IO операции.

Асинхронность c блокируемым IO использует тредпулы - это обычные блокируемые IO операции, например http клиент,  который блокирует поток в тредпуле до завершения операции. 

Асинхронность с не блокируемым IO использует специальное системное API, которое позволяет запустить IO операцию и получить уведомление о ее завершении или самостоятельно проверить завершилась ли операция. Такой подход позволяет не использовать потоки и тредпулы, благодаря чему экономятся ресурсы сервера.

Так что стоит быть осторожным когда вы используете клиенты возвращающие Futures, под этой Futures может находится как блокируемая так и не блокируемая IO операция.

Есть еще бессмысленный и бесполезный подход - синхронные операции с не блокируемым IO - это когда мы запускаем IO операцию и в цикле постоянно проверяем готов ли ее результат, тем самым самостоятельно явно блокируя поток. Использовать такой подход можно только в скриптах и прототипах, когда не жалко ресурсы и лень делать нормально.

В большинстве современных высоконагруженных сервисах используется именно асинхронное не блокируемое IO, потому что они позволяет достичь гораздо большей производительности по сравнению с блокируемыми IO операциями.

Подробнее про устройство не блокируемых IO операций на Linux можно почитать тут:
http://davmac.org/davpage/linux/async-io.html

Про блокируемые и не блокируемые сокеты можно почитать тут:
https://luminousmen.com/post/asynchronous-programming-blocking-and-non-blocking
